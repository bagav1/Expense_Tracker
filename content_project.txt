app/
├── config.py
├── dependencies.py
├── main.py
├── models/
│	├── account_model.py
│	├── category_model.py
│	├── models.py
│	├── transaction_model.py
│	├── user_model.py
├── routers/
│	├── accounts.py
│	├── auth.py
│	├── categories.py
│	├── transactions.py
│	├── users.py
├── schemas/
│	├── schemas.py
└── services/
│	├── database.py


### FILE: config.py
import os
from dotenv import load_dotenv

load_dotenv()


class Config:
    DB_CONFIG = os.environ.get(
        "PG_URI",
        "postgresql+asyncpg://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:${DB_PORT}/{DB_NAME}".format(
            DB_USER=os.environ.get("PG_USER", "fastapi"),
            DB_PASSWORD=os.environ.get("PG_PASS", "fastapi-password"),
            DB_HOST=os.environ.get("PG_HOST", "fastapi-postgresql"),
            DB_PORT=os.environ.get("PG_PORT", "5432"),
            DB_NAME=os.environ.get("PG_DB", "fastapi"),
        ),
    )


config = Config

### END_FILE

### FILE: dependencies.py
import jwt
import os
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jwt.exceptions import DecodeError
from dotenv import load_dotenv

load_dotenv()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login/access-token")


def get_current_user(token: str = Depends(oauth2_scheme)) -> str:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(
            token,
            os.environ.get("SECRET_KEY", ""),
            algorithms=[os.environ.get("ALGORITHM", "")],
        )
        user_id = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        return user_id
    except DecodeError:
        raise credentials_exception

### END_FILE

### FILE: main.py
from fastapi import FastAPI, Depends
from fastapi.middleware.cors import CORSMiddleware
from app.routers import auth, users, accounts
from app.dependencies import oauth2_scheme

app = FastAPI(title="Expense Tracker", version="0.1.0")

origins = [
    "*",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(auth.router)
app.include_router(users.router)
app.include_router(accounts.router, dependencies=[Depends(oauth2_scheme)])

### END_FILE

### FILE: models > account_model.py
import uuid
from sqlalchemy.types import CHAR, Numeric
from sqlalchemy import String, NUMERIC, ForeignKey, select
from sqlalchemy.exc import NoResultFound
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.services.database import BaseClass
from app.models.models import *


class Account(BaseClass):
    __tablename__ = "accounts"
    account_id: Mapped[str] = mapped_column(
        CHAR(32),
        primary_key=True,
        unique=True,
        nullable=False,
        default=lambda: uuid.uuid4().hex,
    )
    user_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("users.user_id"), nullable=False
    )
    account_name: Mapped[str] = mapped_column(String(255), nullable=False)
    account_type: Mapped[str] = mapped_column(String(50), nullable=False)
    initial_balance: Mapped[Numeric] = mapped_column(NUMERIC(10, 2), default=0)
    currency: Mapped[str] = mapped_column(String(3), nullable=False, default="COP")

    user = relationship("User", back_populates="accounts")
    transactions = relationship("Transaction", back_populates="account")

    @classmethod
    async def create(cls, db: AsyncSession, id=None, **kwargs):
        if not id:
            id = uuid.uuid4().hex

        transaction = cls(id=id, **kwargs)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def get(cls, db: AsyncSession, id: str, user_id: str):
        try:
            transaction = await db.get(cls, (id, user_id))
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_all(
        cls, db: AsyncSession, user_id: str, skip: int = 0, limit: int = 100
    ):
        return (
            (
                await db.execute(
                    select(cls).filter(cls.user_id == user_id).offset(skip).limit(limit)
                )
            )
            .scalars()
            .all()
        )

    @classmethod
    async def update(cls, db: AsyncSession, id: str, user_id: str, **kwargs):
        try:
            transaction = await db.get(cls, (id, user_id))
        except NoResultFound:
            return None
        for key, value in kwargs.items():
            setattr(transaction, key, value)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def delete(cls, db: AsyncSession, id: str, user_id: str):
        try:
            transaction = await db.get(cls, (id, user_id))
        except NoResultFound:
            return None
        await db.delete(transaction)
        await db.commit()
        return transaction

### END_FILE

### FILE: models > category_model.py
import uuid
from sqlalchemy.types import CHAR
from sqlalchemy import String, ForeignKey, select
from sqlalchemy.exc import NoResultFound
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.services.database import BaseClass
from app.models.models import *


class Category(BaseClass):
    __tablename__ = "categories"
    category_id: Mapped[str] = mapped_column(
        CHAR(32),
        primary_key=True,
        unique=True,
        nullable=False,
        default=lambda: uuid.uuid4().hex,
    )
    user_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("users.user_id"), nullable=False
    )
    category_name: Mapped[str] = mapped_column(String(255), nullable=False)
    category_type: Mapped[str] = mapped_column(String(50), nullable=False)
    parent_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("categories.category_id"), nullable=True
    )

    user = relationship("User", back_populates="categories")
    transactions = relationship("Transaction", back_populates="category")

    @classmethod
    async def create(cls, db: AsyncSession, id=None, **kwargs):
        if not id:
            id = uuid.uuid4().hex

        transaction = cls(id=id, **kwargs)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def get(cls, db: AsyncSession, id: str, user_id: str):
        try:
            transaction = await db.get(cls, (id, user_id))
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_by_parent(
        cls,
        db: AsyncSession,
        user_id: str,
        parent_id: str,
        skip: int = 0,
        limit: int = 100,
    ):
        return (
            (
                await db.execute(
                    select(cls)
                    .filter(cls.user_id == user_id)
                    .filter(cls.parent_id == parent_id)
                    .offset(skip)
                    .limit(limit)
                )
            )
            .scalars()
            .all()
        )

    @classmethod
    async def get_all(
        cls,
        db: AsyncSession,
        user_id: str,
        skip: int = 0,
        limit: int = 100,
    ):
        return (
            (
                await db.execute(
                    select(cls).filter(cls.user_id == user_id).offset(skip).limit(limit)
                )
            )
            .scalars()
            .all()
        )

    @classmethod
    async def update(cls, db: AsyncSession, id: str, user_id: str, **kwargs):
        try:
            transaction = await db.get(cls, (id, user_id))
        except NoResultFound:
            return None
        for key, value in kwargs.items():
            setattr(transaction, key, value)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def delete(cls, db: AsyncSession, id: str, user_id: str):
        try:
            transaction = await db.get(cls, (id, user_id))
        except NoResultFound:
            return None
        await db.delete(transaction)
        await db.commit()
        return transaction

### END_FILE

### FILE: models > models.py
from app.models.account_model import Account
from app.models.user_model import User
from app.models.category_model import Category
from app.models.transaction_model import Transaction

### END_FILE

### FILE: models > transaction_model.py
import uuid
from sqlalchemy.types import CHAR, Numeric, Date as DateType
from sqlalchemy import String, Date, NUMERIC, ForeignKey, select
from sqlalchemy.exc import NoResultFound
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.services.database import BaseClass
from app.models.models import *


class Transaction(BaseClass):
    __tablename__ = "transactions"
    transaction_id: Mapped[str] = mapped_column(
        CHAR(32),
        primary_key=True,
        unique=True,
        nullable=False,
        default=lambda: uuid.uuid4().hex,
    )
    user_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("users.user_id"), nullable=False
    )
    account_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("accounts.account_id"), nullable=False
    )
    category_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("categories.category_id"), nullable=False
    )
    date: Mapped[DateType] = mapped_column(Date, nullable=False)
    description: Mapped[str] = mapped_column(String(255))
    amount: Mapped[Numeric] = mapped_column(NUMERIC(10, 2), nullable=False)
    transaction_type: Mapped[str] = mapped_column(String(10), nullable=False)
    payment_method: Mapped[str] = mapped_column(String(50))
    notes: Mapped[str] = mapped_column(String(255))

    user = relationship("User")
    account = relationship("Account")
    category = relationship("Category")

    @classmethod
    async def create(cls, db: AsyncSession, id=None, **kwargs):
        if not id:
            id = uuid.uuid4().hex

        transaction = cls(id=id, **kwargs)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def get(cls, db: AsyncSession, id: str, user_id: str):
        try:
            transaction = await db.get(cls, (id, user_id))
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_all(
        cls,
        db: AsyncSession,
        user_id: str,
        skip: int = 0,
        limit: int = 100,
    ):
        return (
            (
                await db.execute(
                    select(cls).filter(cls.user_id == user_id).offset(skip).limit(limit)
                )
            )
            .scalars()
            .all()
        )

    @classmethod
    async def get_by_category(
        cls,
        db: AsyncSession,
        user_id: str,
        category_id: str,
        skip: int = 0,
        limit: int = 100,
    ):
        return (
            (
                await db.execute(
                    select(cls)
                    .filter(cls.user_id == user_id)
                    .filter(cls.category_id == category_id)
                    .offset(skip)
                    .limit(limit)
                )
            )
            .scalars()
            .all()
        )

    @classmethod
    async def get_by_account(
        cls,
        db: AsyncSession,
        user_id: str,
        account_id: str,
        skip: int = 0,
        limit: int = 100,
    ):
        return (
            (
                await db.execute(
                    select(cls)
                    .filter(cls.user_id == user_id)
                    .filter(cls.account_id == account_id)
                    .offset(skip)
                    .limit(limit)
                )
            )
            .scalars()
            .all()
        )

    @classmethod
    async def update(cls, db: AsyncSession, id: str, user_id: str, **kwargs):
        try:
            transaction = await db.get(cls, (id, user_id))
        except NoResultFound:
            return None
        for key, value in kwargs.items():
            setattr(transaction, key, value)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def delete(cls, db: AsyncSession, id: str, user_id: str):
        try:
            transaction = await db.get(cls, (id, user_id))
        except NoResultFound:
            return None
        await db.delete(transaction)
        await db.commit()
        return transaction

### END_FILE

### FILE: models > user_model.py
import uuid
from sqlalchemy.types import CHAR, DateTime as DateTimeType
from sqlalchemy import String, DateTime, select
from sqlalchemy.exc import NoResultFound
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.sql import func

from app.services.database import BaseClass
from app.models.models import *


class User(BaseClass):
    __tablename__ = "users"

    user_id: Mapped[str] = mapped_column(
        CHAR(32),
        primary_key=True,
        unique=True,
        nullable=False,
        default=lambda: uuid.uuid4().hex,
    )
    name: Mapped[str] = mapped_column(String(255), nullable=False)
    email: Mapped[str] = mapped_column(String(255), nullable=False, unique=True)
    password: Mapped[str] = mapped_column(String(255), nullable=False)
    registered_at: Mapped[DateTimeType] = mapped_column(
        DateTime, server_default=func.now()
    )

    accounts = relationship("Account", back_populates="user", cascade="all, delete")
    categories = relationship("Category", back_populates="user", cascade="all, delete")
    transactions = relationship(
        "Transaction", back_populates="user", cascade="all, delete"
    )

    @classmethod
    async def create(cls, db: AsyncSession, id=None, **kwargs):
        if not id:
            id = uuid.uuid4().hex

        transaction = cls(id=id, **kwargs)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def get(cls, db: AsyncSession, id: str):
        try:
            transaction = await db.get(cls, id)
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_all(cls, db: AsyncSession, skip: int = 0, limit: int = 100):
        return (await db.execute(select(cls).offset(skip).limit(limit))).scalars().all()

    @classmethod
    async def update(cls, db: AsyncSession, id: str, **kwargs):
        try:
            transaction = await db.get(cls, id)
        except NoResultFound:
            return None
        for key, value in kwargs.items():
            setattr(transaction, key, value)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def delete(cls, db: AsyncSession, id: str):
        try:
            transaction = await db.get(cls, id)
        except NoResultFound:
            return None
        await db.delete(transaction)
        await db.commit()
        return transaction

### END_FILE

### FILE: routers > accounts.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.schemas.schemas import AccountBase, Account
from app.models.models import Account as AccountModel
from app.dependencies import get_current_user
from app.services.database import get_db

router = APIRouter(
    prefix="/accounts",
    tags=["accounts"],
    responses={404: {"description": "Not found"}},
)


@router.post("/", response_model=Account)
async def create_account(
    account: AccountBase,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    db_account = await AccountModel.create(
        db, **account.model_dump(), user_id=current_user_id
    )
    return db_account


@router.get("/", response_model=list[Account])
async def read_accounts(
    skip: int = 0,
    limit: int = 10,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    accounts = await AccountModel.get_all(
        db, user_id=current_user_id, skip=skip, limit=limit
    )
    return accounts


@router.get("/{account_id}", response_model=Account)
async def read_account(
    account_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    account = await AccountModel.get(db, id=account_id, user_id=current_user_id)
    if account is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Account not found"
        )
    return account


@router.put("/{account_id}", response_model=Account)
async def update_account(
    account_id: str,
    account: AccountBase,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    updated_account = await AccountModel.update(
        db, id=account_id, user_id=current_user_id, **account.model_dump()
    )
    if not updated_account:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Account not found"
        )
    return updated_account


@router.delete("/{account_id}", response_model=Account)
async def delete_account(
    account_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    deleted_account = await AccountModel.delete(
        db, id=account_id, user_id=current_user_id
    )
    if not deleted_account:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Account not found"
        )
    return deleted_account

### END_FILE

### FILE: routers > auth.py
import jwt, os
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from passlib.context import CryptContext
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
from dotenv import load_dotenv

from app.services.database import get_db
from app.models.models import User

load_dotenv()

router = APIRouter(
    prefix="/auth",
    tags=["auth"],
    responses={404: {"description": "Not found"}},
)

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def authenticate_user(db, email: str, password: str):
    user = db.query(User).filter(User.email == email).first()
    if not user or not pwd_context.verify(password, user.password):
        return None
    return user


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(
        to_encode,
        os.environ.get("SECRET_KEY", ""),
        algorithm=os.environ.get("ALGORITHM", ""),
    )
    return encoded_jwt


@router.post("/login/access-token")
def login_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(), db: AsyncSession = Depends(get_db)
):
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(
        days=float(os.environ.get("ACCESS_TOKEN_EXPIRE_DAYS", ""))
    )
    access_token = create_access_token(
        data={"sub": user.user_id}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}


@router.post("/logout")
def logout():
    return {"message": "Logout successful"}

### END_FILE

### FILE: routers > categories.py
# En contruccion...
### END_FILE

### FILE: routers > transactions.py
# En contruccion...
### END_FILE

### FILE: routers > users.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError
from passlib.context import CryptContext

from app.dependencies import get_current_user
from app.services.database import get_db
from app.schemas.schemas import UserBase, User
from app.models.models import User as UserModel

router = APIRouter(
    prefix="/users",
    tags=["users"],
    responses={404: {"description": "Not found"}},
)

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


@router.post("/", response_model=User, dependencies=[])
async def create_user(user: UserBase, db: AsyncSession = Depends(get_db)):
    hashed_password = pwd_context.hash(user.password)
    try:
        user = await UserModel.create(
            db, name=user.name, email=user.email, password=hashed_password
        )
        return user
    except IntegrityError:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="User with this email already exists",
        )


@router.get("/", response_model=list[User])
async def read_users(
    skip: int = 0,
    limit: int = 10,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    users = await UserModel.get_all(db, skip=skip, limit=limit)
    users_without_password = []
    for user in users:
        user_dict = user.__dict__
        user_dict.update({"password": "hidden"})
        users_without_password.append(user_dict)
    return users_without_password


@router.get("/{user_id}", response_model=User)
async def read_user(
    user_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    if user_id != current_user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="You are not authorized to access this resource",
        )
    user = await UserModel.get(db, user_id)
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    user_dict = user.__dict__
    user_dict.update({"password": "hidden"})
    return user_dict


@router.put("/{user_id}", response_model=User)
async def update_user(
    user_id: str,
    user: UserBase,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    if user_id != current_user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="You are not authorized to access this resource",
        )
    db_user = await UserModel.update(db, user_id, **user.model_dump())
    if db_user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    user_dict = db_user.__dict__
    user_dict.update({"password": "hidden"})
    return user_dict


@router.delete("/{user_id}", response_model=User)
async def delete_user(
    user_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    if user_id != current_user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="You are not authorized to access this resource",
        )
    db_user = await UserModel.delete(db, user_id)
    if db_user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    user_dict = db_user.__dict__
    user_dict.update({"password": "hidden"})
    return user_dict

### END_FILE

### FILE: schemas > schemas.py
from pydantic import BaseModel, Field


class UserBase(BaseModel):
    name: str = Field(..., title="User Name")
    email: str = Field(..., title="User Email")
    password: str = Field(..., title="User Password")


class User(UserBase):
    user_id: str

    class Config:
        from_attributes = True


class AccountBase(BaseModel):
    account_name: str = Field(..., title="Account Name")
    account_type: str = Field(..., title="Account Type")
    initial_balance: float = Field(default=0.0, title="Initial Balance")
    currency: str = Field(default="COP", title="Currency")


class Account(AccountBase):
    account_id: str
    user_id: str

    class Config:
        from_attributes = True

### END_FILE

### FILE: services > database.py
import contextlib
from typing import AsyncIterator

from fastapi import Depends
from sqlalchemy.ext.asyncio import (
    AsyncConnection,
    AsyncEngine,
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.orm import DeclarativeBase


class BaseClass(DeclarativeBase):
    pass


class DatabaseSessionManager:
    def __init__(self):
        self._engine: AsyncEngine | None = None
        self._sessionmaker: async_sessionmaker | None = None

    def init(self, host: str):
        self._engine = create_async_engine(host)
        self._sessionmaker = async_sessionmaker(autocommit=False, bind=self._engine)

    async def close(self):
        if self._engine is None:
            raise Exception("DatabaseSessionManager is not initialized")
        await self._engine.dispose()
        self._engine = None
        self._sessionmaker = None

    @contextlib.asynccontextmanager
    async def connect(self) -> AsyncIterator[AsyncConnection]:
        if self._engine is None:
            raise Exception("DatabaseSessionManager is not initialized")

        async with self._engine.begin() as connection:
            try:
                yield connection
            except Exception:
                await connection.rollback()
                raise

    @contextlib.asynccontextmanager
    async def session(self) -> AsyncIterator[AsyncSession]:
        if self._sessionmaker is None:
            raise Exception("DatabaseSessionManager is not initialized")

        session = self._sessionmaker()
        try:
            yield session
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()

    # Used for testing
    async def create_all(self, connection: AsyncConnection):
        await connection.run_sync(BaseClass.metadata.create_all)

    async def drop_all(self, connection: AsyncConnection):
        await connection.run_sync(BaseClass.metadata.drop_all)


sessionmanager = DatabaseSessionManager()


async def get_db():
    async with sessionmanager.session() as session:
        yield session

### END_FILE

