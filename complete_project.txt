./
├── .gitignore
├── alembic.ini
├── dev.sh
├── LICENSE
├── mypy.ini
├── pytest.ini
├── README.md
├── requirements.txt
├── run.py
├── app/
│	├── config.py
│	├── dependencies.py
│	├── utils.py
│	├── models/
│	│	├── account_model.py
│	│	├── category_model.py
│	│	├── models.py
│	│	├── transaction_model.py
│	│	├── user_model.py
│	├── routers/
│	│	├── accounts.py
│	│	├── auth.py
│	│	├── categories.py
│	│	├── transactions.py
│	│	├── users.py
│	├── schemas/
│	│	├── schemas.py
│	└── services/
│	│	├── database.py
└── tests/
│	├── integration/
│	│	├── config_test.py
│	│	├── test_user_router.py
│	└── models/
│	│	├── test_account_model.py
│	│	├── test_category_model.py
│	│	├── test_transaction_model.py
│	│	├── test_user_model.py


### FILE: .gitignore
# Byte-compiled / optimized / DLL files
.vscode/
notebooks/
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Backup files
*~
.*~

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
share/
bin/
lib/
lib64
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints
etc/jupyter

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
Linguo_API_env/
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

*_bkp.csv
*_test.py
dev.sh
app/files_tmp/
### END_FILE

### FILE: alembic.ini
# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

### END_FILE

### FILE: dev.sh
clear
uvicorn run:server --host="0.0.0.0" --port=5503 --log-level="debug" --reload
### END_FILE

### FILE: LICENSE
The MIT License (MIT)

Copyright (c) 2024 Bryan Garcia

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
### END_FILE

### FILE: mypy.ini
[mypy]
check_untyped_defs = true
namespace_packages = true
plugins = sqlalchemy.ext.mypy.plugin
pretty = true
show_error_context = true
exclude = (?x)(.venv$)

[mypy.tests.*]
ignore_errors = true

[mypy.backoff.*]
ignore_missing_imports = true

[mypy.opentracing.*]
ignore_missing_imports = true
### END_FILE

### FILE: pytest.ini
[pytest]
testpaths = tests
python_files = test_*.py
python_functions = test_*
python_classes = Test* *Tests
addopts = -vv -x
asyncio_mode = auto

### END_FILE

### FILE: README.md
# Expense Tracker

Este archivo presenta una guía completa para el proyecto Expense Tracker, una API construida sobre FastAPI para rastrear y gestionar finanzas personales. Ofrece funcionalidades para la gestión de cuentas, transacciones, categorías y autenticación de usuarios.

## Características principales

- **Gestión de cuentas**: Creación y gestión de cuentas financieras.
- **Gestión de categorías**: Creación y organización de ingresos y gastos en categorías personalizables.
- **Transacciones**: Registro y seguimiento de transacciones bajo cuentas y categorías específicas.
- **Autenticación**: Soporte para la autenticación de usuarios y administración de acceso seguro.

## Tecnologías utilizadas

Este proyecto utiliza las siguientes tecnologías y bibliotecas:

- [FastAPI](https://fastapi.tiangolo.com/): Para construir una API rápida y con documentación interactiva.
- [SQLAlchemy](https://www.sqlalchemy.org/): Como ORM para interactuar de manera eficiente con bases de datos.
- [Alembic](https://alembic.sqlalchemy.org/): Para la migración de bases de datos.
- [Pytest](https://pytest.org/): Utilizado para las pruebas unitarias y de integración.

## Estructura del proyecto

El proyecto está estructurado de la siguiente manera:

- `./app`: Contiene todo el código fuente, incluidos modelos, rutas y servicios.
- `./tests`: Almacena pruebas unitarias y de integración para garantizar la robustez del proyecto.
- `requirements.txt`: Lista de todas las dependencias necesarias para el proyecto.
- `.env`: Archivo para definir variables de entorno (se proporciona como ejemplo).

## Cómo empezar

Asegúrate de tener Python 3.8 o superior instalado en tu sistema. Para instalar el proyecto y sus dependencias, sigue estos pasos:

1. Clona el repositorio del proyecto.
2. Crea un entorno virtual:

```bash
python -m venv venv
```

3. Activa el entorno virtual:

- En Windows:

```cmd
venv\Scripts\activate
```

- En UNIX o MacOS:

```bash
source venv/bin/activate
```

4. Instala las dependencias:

```bash
pip install -r requirements.txt
```

5. Inicia el servidor:

```bash
uvicorn run:server --reload
```

Visita `http://127.0.0.1:8000/docs` en tu navegador para acceder a la documentación y probar la API.

## Contribuir

Si deseas contribuir a este proyecto, por favor sigue las siguientes recomendaciones:

- Haz fork y clona el repositorio.
- Crea una rama nueva para tu característica o corrección de errores.
- Efectúa tus cambios de manera limpia y asegúrate de agregar pruebas si es necesario.
- Envía un pull request con tus cambios.

## Licencia

Este proyecto está bajo la licencia MIT. Para más detalles, consulta el archivo `LICENSE` en el repositorio.
### END_FILE

### FILE: requirements.txt
uvicorn[standard]
fastapi==0.110.0
passlib==1.7.4
types-passlib==1.7.7.20240106
bcrypt==4.0.1
pytest==8.0.2
# pytest-asyncio==0.23.5
# pytest-postgresql==5.1.0
httpx==0.27.0
python-multipart==0.0.9
python-dotenv==1.0.1
pydantic==2.6.3
psycopg2-binary==2.9.9
PyJWT==2.8.0
alembic==1.13.1
asyncpg==0.29.0
mypy==1.8.0
sqlalchemy[mypy]==2.0.27
pytz==2024.1
types-pytz==2024.1.0.20240203
### END_FILE

### FILE: run.py
#!/usr/bin/env python3
from app import init_app

server = init_app()

### END_FILE

### FILE: app > config.py
import os
from dotenv import load_dotenv

load_dotenv()


class Config:
    DB_CONFIG = os.environ.get(
        "PG_URI",
        "postgresql+asyncpg://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:${DB_PORT}/{DB_NAME}".format(
            DB_USER=os.environ.get("PG_USER", "fastapi"),
            DB_PASSWORD=os.environ.get("PG_PASS", "fastapi-password"),
            DB_HOST=os.environ.get("PG_HOST", "fastapi-postgresql"),
            DB_PORT=os.environ.get("PG_PORT", "5432"),
            DB_NAME=os.environ.get("PG_DB", "fastapi"),
        ),
    )


config = Config

### END_FILE

### FILE: app > dependencies.py
import jwt
import os
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jwt.exceptions import DecodeError
from dotenv import load_dotenv

load_dotenv()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login/access-token")


def get_current_user(token: str = Depends(oauth2_scheme)) -> str:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(
            token,
            os.environ.get("SECRET_KEY", ""),
            algorithms=[os.environ.get("ALGORITHM", "")],
        )
        user_id = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        return user_id
    except DecodeError:
        raise credentials_exception

### END_FILE

### FILE: app > utils.py
import pytz, os
from datetime import datetime
from dotenv import load_dotenv

load_dotenv()


class DateFormat:
    def __init__(self, date: datetime):
        self.date = date

    @classmethod
    def to_string(self, date: datetime) -> str:
        return datetime.strftime(date, "%Y-%m-%d %H:%M:%S")

    @classmethod
    def from_iso(cls, date: str) -> "DateFormat":
        if date.endswith("Z"):
            date = date[:-1]
        return cls(datetime.fromisoformat(date))

    @classmethod
    def from_timestamp(cls, date: str) -> "DateFormat":
        return cls(datetime.utcfromtimestamp(int(date) / 1000.0))

    def to_local(self) -> datetime:
        tz = pytz.timezone(os.environ.get("TZ", "UTC"))
        return self.date.astimezone(tz)

    def as_datetime(self) -> datetime:
        return self.date

### END_FILE

### FILE: app > models > account_model.py
import uuid
from sqlalchemy.types import CHAR, Numeric
from sqlalchemy import String, NUMERIC, ForeignKey, select
from sqlalchemy.exc import NoResultFound
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.services.database import BaseClass
from app.models.models import *


class Account(BaseClass):
    __tablename__ = "accounts"
    account_id: Mapped[str] = mapped_column(
        CHAR(32),
        primary_key=True,
        unique=True,
        nullable=False,
        default=lambda: uuid.uuid4().hex,
    )
    user_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("users.user_id"), nullable=False
    )
    account_name: Mapped[str] = mapped_column(String(255), nullable=False)
    account_type: Mapped[str] = mapped_column(String(50), nullable=False)
    initial_balance: Mapped[Numeric] = mapped_column(
        NUMERIC(10, 2), default=0, server_default="0"
    )
    currency: Mapped[str] = mapped_column(
        String(3), nullable=False, default="COP", server_default="COP"
    )

    user = relationship("User", back_populates="accounts")
    transactions = relationship("Transaction", back_populates="account")

    @classmethod
    async def create(cls, db: AsyncSession, account_id=None, **kwargs):
        if not account_id:
            account_id = uuid.uuid4().hex

        transaction = cls(account_id=account_id, **kwargs)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def get(cls, db: AsyncSession, account_id: str, user_id: str):
        try:
            transaction = (
                (
                    await db.execute(
                        select(cls)
                        .filter(cls.account_id == account_id)
                        .filter(cls.user_id == user_id)
                    )
                )
                .scalars()
                .first()
            )
            if not transaction:
                return None
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_all(
        cls, db: AsyncSession, user_id: str, skip: int = 0, limit: int = 100
    ):
        try:
            transaction = (
                (
                    await db.execute(
                        select(cls)
                        .filter(cls.user_id == user_id)
                        .offset(skip)
                        .limit(limit)
                    )
                )
                .scalars()
                .all()
            )
            if not transaction:
                return None
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def update(cls, db: AsyncSession, account_id: str, user_id: str, **kwargs):
        try:
            transaction = await cls.get(db, account_id, user_id)
            if not transaction:
                return None
        except NoResultFound:
            return None
        for key, value in kwargs.items():
            setattr(transaction, key, value)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def delete(cls, db: AsyncSession, account_id: str, user_id: str):
        try:
            transaction = await cls.get(db, account_id, user_id)
            if not transaction:
                return None
        except NoResultFound:
            return None
        await db.delete(transaction)
        await db.commit()
        return transaction

### END_FILE

### FILE: app > models > category_model.py
import uuid
from sqlalchemy.types import CHAR
from sqlalchemy import String, ForeignKey, select
from sqlalchemy.exc import NoResultFound
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.services.database import BaseClass
from app.models.models import *


class Category(BaseClass):
    __tablename__ = "categories"
    category_id: Mapped[str] = mapped_column(
        CHAR(32),
        primary_key=True,
        unique=True,
        nullable=False,
        default=lambda: uuid.uuid4().hex,
    )
    user_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("users.user_id"), nullable=False
    )
    category_name: Mapped[str] = mapped_column(String(255), nullable=False)
    category_type: Mapped[str] = mapped_column(String(50), nullable=False)
    parent_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("categories.category_id"), nullable=True
    )

    user = relationship("User", back_populates="categories")
    transactions = relationship("Transaction", back_populates="category")

    @classmethod
    async def create(cls, db: AsyncSession, category_id=None, **kwargs):
        if not category_id:
            category_id = uuid.uuid4().hex

        transaction = cls(category_id=category_id, **kwargs)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def get(cls, db: AsyncSession, category_id: str, user_id: str):
        try:
            transaction = (
                (
                    await db.execute(
                        select(cls)
                        .filter(cls.category_id == category_id)
                        .filter(cls.user_id == user_id)
                    )
                )
                .scalars()
                .first()
            )
            if not transaction:
                return None
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_by_parent(
        cls,
        db: AsyncSession,
        user_id: str,
        parent_id: str,
        skip: int = 0,
        limit: int = 100,
    ):
        try:
            transaction = (
                (
                    await db.execute(
                        select(cls)
                        .filter(cls.user_id == user_id)
                        .filter(cls.parent_id == parent_id)
                        .offset(skip)
                        .limit(limit)
                    )
                )
                .scalars()
                .all()
            )
            if not transaction:
                return None
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_all(
        cls,
        db: AsyncSession,
        user_id: str,
        skip: int = 0,
        limit: int = 100,
    ):
        try:
            transaction = (
                (
                    await db.execute(
                        select(cls)
                        .filter(cls.user_id == user_id)
                        .offset(skip)
                        .limit(limit)
                    )
                )
                .scalars()
                .all()
            )
            if not transaction:
                return None
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def update(cls, db: AsyncSession, category_id: str, user_id: str, **kwargs):
        try:
            transaction = await cls.get(db, category_id, user_id)
            if not transaction:
                return None
        except NoResultFound:
            return None
        for key, value in kwargs.items():
            setattr(transaction, key, value)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def delete(cls, db: AsyncSession, category_id: str, user_id: str):
        try:
            transaction = await cls.get(db, category_id, user_id)
            if not transaction:
                return None
        except NoResultFound:
            return None
        await db.delete(transaction)
        await db.commit()
        return transaction

### END_FILE

### FILE: app > models > models.py
from app.models.account_model import Account
from app.models.user_model import User
from app.models.category_model import Category
from app.models.transaction_model import Transaction

### END_FILE

### FILE: app > models > transaction_model.py
import uuid, datetime
from sqlalchemy.types import CHAR, Numeric
from sqlalchemy import String, DateTime, NUMERIC, ForeignKey, select
from sqlalchemy.exc import NoResultFound
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.services.database import BaseClass
from app.models.models import *


class Transaction(BaseClass):
    __tablename__ = "transactions"
    transaction_id: Mapped[str] = mapped_column(
        CHAR(32),
        primary_key=True,
        unique=True,
        nullable=False,
        default=lambda: uuid.uuid4().hex,
    )
    user_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("users.user_id"), nullable=False
    )
    account_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("accounts.account_id"), nullable=False
    )
    category_id: Mapped[str] = mapped_column(
        CHAR(32), ForeignKey("categories.category_id"), nullable=False
    )
    date: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True), nullable=False
    )
    description: Mapped[str] = mapped_column(String(255))
    amount: Mapped[Numeric] = mapped_column(NUMERIC(10, 2), nullable=False)
    transaction_type: Mapped[str] = mapped_column(String(10), nullable=False)
    payment_method: Mapped[str] = mapped_column(String(50))
    notes: Mapped[str] = mapped_column(String(255))

    user = relationship("User")
    account = relationship("Account")
    category = relationship("Category")

    @classmethod
    async def create(cls, db: AsyncSession, transaction_id=None, **kwargs):
        if not transaction_id:
            transaction_id = uuid.uuid4().hex

        transaction = cls(transaction_id=transaction_id, **kwargs)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def get(cls, db: AsyncSession, transaction_id: str, user_id: str):
        try:
            transaction = (
                (
                    await db.execute(
                        select(cls)
                        .filter(cls.transaction_id == transaction_id)
                        .filter(cls.user_id == user_id)
                    )
                )
                .scalars()
                .first()
            )
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_all(
        cls,
        db: AsyncSession,
        user_id: str,
        skip: int = 0,
        limit: int = 100,
    ):
        try:
            transaction = (
                (
                    await db.execute(
                        select(cls)
                        .filter(cls.user_id == user_id)
                        .offset(skip)
                        .limit(limit)
                    )
                )
                .scalars()
                .all()
            )
            if not transaction:
                return None
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_by_category(
        cls,
        db: AsyncSession,
        user_id: str,
        category_id: str,
        skip: int = 0,
        limit: int = 100,
    ):
        try:
            transaction = (
                (
                    await db.execute(
                        select(cls)
                        .filter(cls.user_id == user_id)
                        .filter(cls.category_id == category_id)
                        .offset(skip)
                        .limit(limit)
                    )
                )
                .scalars()
                .all()
            )
            if not transaction:
                return None
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_by_account(
        cls,
        db: AsyncSession,
        user_id: str,
        account_id: str,
        skip: int = 0,
        limit: int = 100,
    ):
        try:
            transaction = (
                (
                    await db.execute(
                        select(cls)
                        .filter(cls.user_id == user_id)
                        .filter(cls.account_id == account_id)
                        .offset(skip)
                        .limit(limit)
                    )
                )
                .scalars()
                .all()
            )
            if not transaction:
                return None
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def update(
        cls, db: AsyncSession, transaction_id: str, user_id: str, **kwargs
    ):
        try:
            transaction = await cls.get(db, transaction_id, user_id)
            if not transaction:
                return None
        except NoResultFound:
            return None
        for key, value in kwargs.items():
            setattr(transaction, key, value)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def delete(cls, db: AsyncSession, transaction_id: str, user_id: str):
        try:
            transaction = await cls.get(db, transaction_id, user_id)
            if not transaction:
                return None
        except NoResultFound:
            return None
        await db.delete(transaction)
        await db.commit()
        return transaction

### END_FILE

### FILE: app > models > user_model.py
import uuid
from sqlalchemy.types import CHAR, DateTime as DateTimeType
from sqlalchemy import String, DateTime, select
from sqlalchemy.exc import NoResultFound
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.sql import func

from app.services.database import BaseClass
from app.models.models import *


class User(BaseClass):
    __tablename__ = "users"

    user_id: Mapped[str] = mapped_column(
        CHAR(32),
        primary_key=True,
        unique=True,
        nullable=False,
        default=lambda: uuid.uuid4().hex,
    )
    name: Mapped[str] = mapped_column(String(255), nullable=False)
    email: Mapped[str] = mapped_column(String(255), nullable=False, unique=True)
    password: Mapped[str] = mapped_column(String(255), nullable=False)
    registered_at: Mapped[DateTimeType] = mapped_column(
        DateTime, default=func.now(), server_default=func.now()
    )

    accounts = relationship("Account", back_populates="user", cascade="all, delete")
    categories = relationship("Category", back_populates="user", cascade="all, delete")
    transactions = relationship(
        "Transaction", back_populates="user", cascade="all, delete"
    )

    @classmethod
    async def create(cls, db: AsyncSession, user_id=None, **kwargs):
        if not user_id:
            user_id = uuid.uuid4().hex

        transaction = cls(user_id=user_id, **kwargs)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def get(cls, db: AsyncSession, user_id: str):
        try:
            transaction = await db.get(cls, user_id)
            if not transaction:
                return None
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_by_email(cls, db: AsyncSession, email: str):
        try:
            transaction = (
                (await db.execute(select(cls).filter(cls.email == email)))
                .scalars()
                .first()
            )
            if not transaction:
                return None
        except NoResultFound:
            return None
        return transaction

    @classmethod
    async def get_all(cls, db: AsyncSession, skip: int = 0, limit: int = 100):
        return (await db.execute(select(cls).offset(skip).limit(limit))).scalars().all()

    @classmethod
    async def update(cls, db: AsyncSession, user_id: str, **kwargs):
        try:
            transaction = await db.get(cls, user_id)
            if not transaction:
                return None
        except NoResultFound:
            return None
        for key, value in kwargs.items():
            setattr(transaction, key, value)
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        return transaction

    @classmethod
    async def delete(cls, db: AsyncSession, user_id: str):
        try:
            transaction = await db.get(cls, user_id)
            if not transaction:
                return None
        except NoResultFound:
            return None
        await db.delete(transaction)
        await db.commit()
        return transaction

### END_FILE

### FILE: app > routers > accounts.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.schemas.schemas import AccountBase, Account
from app.models.models import Account as AccountModel
from app.dependencies import get_current_user
from app.services.database import get_db

router = APIRouter(
    prefix="/accounts",
    tags=["accounts"],
    responses={404: {"description": "Not found"}},
)


@router.post("/", response_model=Account)
async def create_account(
    account: AccountBase,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    db_account = await AccountModel.create(
        db, **account.model_dump(), user_id=current_user_id
    )
    return db_account


@router.get("/", response_model=list[Account])
async def read_accounts(
    skip: int = 0,
    limit: int = 10,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    accounts = await AccountModel.get_all(
        db, user_id=current_user_id, skip=skip, limit=limit
    )
    return accounts


@router.get("/{account_id}", response_model=Account)
async def read_account(
    account_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    account = await AccountModel.get(db, account_id=account_id, user_id=current_user_id)
    if account is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Account not found"
        )
    return account


@router.put("/{account_id}", response_model=Account)
async def update_account(
    account_id: str,
    account: AccountBase,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    updated_account = await AccountModel.update(
        db, account_id=account_id, user_id=current_user_id, **account.model_dump()
    )
    if not updated_account:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Account not found"
        )
    return updated_account


@router.delete("/{account_id}", response_model=Account)
async def delete_account(
    account_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    deleted_account = await AccountModel.delete(
        db, account_id=account_id, user_id=current_user_id
    )
    if not deleted_account:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Account not found"
        )
    return deleted_account

### END_FILE

### FILE: app > routers > auth.py
import jwt, os
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from passlib.context import CryptContext
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
from dotenv import load_dotenv

from app.services.database import get_db
from app.models.models import User as UserModel

load_dotenv()

router = APIRouter(
    prefix="/auth",
    tags=["auth"],
    responses={404: {"description": "Not found"}},
)

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


async def authenticate_user(db, email: str, password: str):
    user = await UserModel.get_by_email(db, email)
    print(user)
    if not user or not pwd_context.verify(password, user.password):
        return None
    return user


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(
        to_encode,
        os.environ.get("SECRET_KEY", ""),
        algorithm=os.environ.get("ALGORITHM", ""),
    )
    return encoded_jwt


@router.post("/login/access-token")
async def login_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(), db: AsyncSession = Depends(get_db)
):
    user = await authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(
        days=float(os.environ.get("ACCESS_TOKEN_EXPIRE_DAYS", ""))
    )
    access_token = create_access_token(
        data={"sub": user.user_id}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}


@router.post("/logout")
def logout():
    return {"message": "Logout successful"}

### END_FILE

### FILE: app > routers > categories.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.schemas.schemas import CategoryBase, Category
from app.models.models import Category as CategoryModel
from app.dependencies import get_current_user
from app.services.database import get_db

router = APIRouter(
    prefix="/categories",
    tags=["categories"],
    responses={404: {"description": "Not found"}},
)


@router.post("/", response_model=Category)
async def create_category(
    category: CategoryBase,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    db_category = await CategoryModel.create(
        db, **category.model_dump(), user_id=current_user_id
    )
    return db_category


@router.get("/", response_model=list[Category])
async def read_categories(
    skip: int = 0,
    limit: int = 10,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    categories = await CategoryModel.get_all(
        db, user_id=current_user_id, skip=skip, limit=limit
    )
    return categories


@router.get("/{category_id}", response_model=Category)
async def read_category(
    category_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    category = await CategoryModel.get(
        db, category_id=category_id, user_id=current_user_id
    )
    if category is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Category not found"
        )
    return category


@router.put("/{category_id}", response_model=Category)
async def update_category(
    category_id: str,
    category: CategoryBase,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    updated_category = await CategoryModel.update(
        db, category_id=category_id, user_id=current_user_id, **category.model_dump()
    )
    if not updated_category:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Category not found"
        )
    return updated_category


@router.delete("/{category_id}", response_model=Category)
async def delete_category(
    category_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    deleted_category = await CategoryModel.delete(
        db, category_id=category_id, user_id=current_user_id
    )
    if not deleted_category:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Category not found"
        )
    return deleted_category

### END_FILE

### FILE: app > routers > transactions.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.schemas.schemas import TransactionBase, Transaction
from app.models.models import Transaction as TransactionModel
from app.dependencies import get_current_user
from app.services.database import get_db
from app.utils import DateFormat

router = APIRouter(
    prefix="/transactions",
    tags=["transactions"],
    responses={404: {"description": "Not found"}},
)


@router.post("/", response_model=Transaction)
async def create_transaction(
    transaction: TransactionBase,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    model = transaction.model_dump()
    model.update({"date": DateFormat.from_iso(model.get("date", "")).to_local()})
    db_transaction = await TransactionModel.create(db, **model, user_id=current_user_id)
    return db_transaction


@router.get("/", response_model=list[Transaction])
async def read_transactions(
    skip: int = 0,
    limit: int = 10,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    transactions = await TransactionModel.get_all(
        db, user_id=current_user_id, skip=skip, limit=limit
    )
    return transactions


@router.get("/{transaction_id}", response_model=Transaction)
async def read_transaction(
    transaction_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    transaction = await TransactionModel.get(
        db, transaction_id=transaction_id, user_id=current_user_id
    )
    if transaction is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found"
        )
    return transaction


@router.put("/{transaction_id}", response_model=Transaction)
async def update_transaction(
    transaction_id: str,
    transaction: TransactionBase,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    model = transaction.model_dump()
    model.update({"date": DateFormat.from_iso(model.get("date", "")).to_local()})
    updated_transaction = await TransactionModel.update(
        db, transaction_id=transaction_id, user_id=current_user_id, **model
    )
    if not updated_transaction:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found"
        )
    return updated_transaction


@router.delete("/{transaction_id}", response_model=Transaction)
async def delete_transaction(
    transaction_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    deleted_transaction = await TransactionModel.delete(
        db, transaction_id=transaction_id, user_id=current_user_id
    )
    if not deleted_transaction:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Transaction not found"
        )
    return deleted_transaction

### END_FILE

### FILE: app > routers > users.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError
from passlib.context import CryptContext

from app.dependencies import get_current_user
from app.services.database import get_db
from app.schemas.schemas import UserBase, User
from app.models.models import User as UserModel

router = APIRouter(
    prefix="/users",
    tags=["users"],
    responses={404: {"description": "Not found"}},
)

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


@router.post("/", response_model=User, dependencies=[])
async def create_user(user: UserBase, db: AsyncSession = Depends(get_db)):
    hashed_password = pwd_context.hash(user.password)
    try:
        user = await UserModel.create(
            db,
            **{"name": user.name, "email": user.email, "password": hashed_password}
            # name=user.name, email=user.email, password=hashed_password
        )
        return user
    except IntegrityError:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="User with this email already exists",
        )


@router.get("/", response_model=list[User])
async def read_users(
    skip: int = 0,
    limit: int = 10,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    users = await UserModel.get_all(db, skip=skip, limit=limit)
    users_without_password = []
    for user in users:
        user_dict = user.__dict__
        user_dict.update({"password": "hidden"})
        users_without_password.append(user_dict)
    return users_without_password


@router.get("/{user_id}", response_model=User)
async def read_user(
    user_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    if user_id != current_user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="You are not authorized to access this resource",
        )
    user = await UserModel.get(db, user_id)
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    user_dict = user.__dict__
    user_dict.update({"password": "hidden"})
    return user_dict


@router.put("/{user_id}", response_model=User)
async def update_user(
    user_id: str,
    user: UserBase,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    if user_id != current_user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="You are not authorized to access this resource",
        )
    db_user = await UserModel.update(db, user_id, **user.model_dump())
    if db_user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    user_dict = db_user.__dict__
    user_dict.update({"password": "hidden"})
    return user_dict


@router.delete("/{user_id}", response_model=User)
async def delete_user(
    user_id: str,
    db: AsyncSession = Depends(get_db),
    current_user_id: str = Depends(get_current_user),
):
    if user_id != current_user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="You are not authorized to access this resource",
        )
    db_user = await UserModel.delete(db, user_id)
    if db_user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    user_dict = db_user.__dict__
    user_dict.update({"password": "hidden"})
    return user_dict

### END_FILE

### FILE: app > schemas > schemas.py
from typing import Optional
from datetime import datetime
from pydantic import BaseModel, Field


class UserBase(BaseModel):
    name: str = Field(..., title="User Name")
    email: str = Field(..., title="User Email")
    password: str = Field(..., title="User Password")


class User(UserBase):
    user_id: str = Field(title="User ID")

    class Config:
        from_attributes = True


class AccountBase(BaseModel):
    account_name: str = Field(..., title="Account Name")
    account_type: str = Field(..., title="Account Type")
    initial_balance: Optional[str] = Field(default=0.0, title="Initial Balance")
    currency: Optional[str] = Field(default="COP", title="Currency")


class Account(AccountBase):
    account_id: str = Field(title="Account ID")
    user_id: str = Field(title="User Account")

    class Config:
        from_attributes = True


class CategoryBase(BaseModel):
    category_name: str = Field(..., title="Category Name")
    category_type: str = Field(..., title="Category Type")
    parent_id: Optional[str] = Field(None, title="Parent Category")


class Category(CategoryBase):
    category_id: str = Field(title="Category ID")
    user_id: str = Field(title="User Category")

    class Config:
        from_attributes = True


class TransactionBase(BaseModel):
    account_id: str = Field(..., title="Account Transaction")
    category_id: str = Field(..., title="Category Transaction")
    date: str | datetime = Field(..., title="Transaction Date")
    description: Optional[str] = Field(None, title="Transaction Description")
    amount: float = Field(..., title="Transaction Amount")
    transaction_type: str = Field(..., title="Transaction Type")
    payment_method: Optional[str] = Field(None, title="Payment Method")
    notes: Optional[str] = Field(None, title="Transaction Notes")


class Transaction(TransactionBase):
    transaction_id: str = Field(title="Transaction ID")
    user_id: str = Field(title="User Transaction")

    class Config:
        from_attributes = True

### END_FILE

### FILE: app > services > database.py
import contextlib
from typing import AsyncIterator

from fastapi import Depends
from sqlalchemy.ext.asyncio import (
    AsyncConnection,
    AsyncEngine,
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.orm import DeclarativeBase


class BaseClass(DeclarativeBase):
    pass


class DatabaseSessionManager:
    def __init__(self):
        self._engine: AsyncEngine | None = None
        self._sessionmaker: async_sessionmaker | None = None

    def init(self, host: str):
        self._engine = create_async_engine(host)
        self._sessionmaker = async_sessionmaker(autocommit=False, bind=self._engine)

    async def close(self):
        if self._engine is None:
            raise Exception("DatabaseSessionManager is not initialized")
        await self._engine.dispose()
        self._engine = None
        self._sessionmaker = None

    @contextlib.asynccontextmanager
    async def connect(self) -> AsyncIterator[AsyncConnection]:
        if self._engine is None:
            raise Exception("DatabaseSessionManager is not initialized")

        async with self._engine.begin() as connection:
            try:
                yield connection
            except Exception:
                await connection.rollback()
                raise

    @contextlib.asynccontextmanager
    async def session(self) -> AsyncIterator[AsyncSession]:
        if self._sessionmaker is None:
            raise Exception("DatabaseSessionManager is not initialized")

        session = self._sessionmaker()
        try:
            yield session
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()

    # Used for testing
    async def create_all(self, connection: AsyncConnection):
        await connection.run_sync(BaseClass.metadata.create_all)

    async def drop_all(self, connection: AsyncConnection):
        await connection.run_sync(BaseClass.metadata.drop_all)


sessionmanager = DatabaseSessionManager()


async def get_db():
    async with sessionmanager.session() as session:
        yield session

### END_FILE

### FILE: tests > integration > config_test.py
import asyncio, pytest
from contextlib import ExitStack

from fastapi.testclient import TestClient
from pytest_postgresql import factories
from pytest_postgresql.janitor import DatabaseJanitor

from app import init_app
from app.services.database import get_db, sessionmanager


test_db = factories.postgresql_proc(port=None, dbname="test_db")


@pytest.fixture(autouse=True)
def app():
    with ExitStack():
        yield init_app(init_db=False)


@pytest.fixture
def client(app):
    with TestClient(app) as c:
        yield c


@pytest.fixture(scope="session")
def event_loop(request):
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


@pytest.fixture(scope="session", autouse=True)
async def connection_test(test_db, event_loop):
    pg_host = test_db.host
    pg_port = test_db.port
    pg_user = test_db.user
    pg_db = test_db.dbname
    pg_password = test_db.password

    with DatabaseJanitor(
        pg_user, pg_host, pg_port, pg_db, test_db.version, pg_password
    ):
        connection_str = f"postgresql+psycopg://{pg_user}:@{pg_host}:{pg_port}/{pg_db}"
        sessionmanager.init(connection_str)
        yield
        await sessionmanager.close()


@pytest.fixture(scope="function", autouse=True)
async def create_tables(connection_test):
    async with sessionmanager.connect() as connection:
        await sessionmanager.drop_all(connection)
        await sessionmanager.create_all(connection)


@pytest.fixture(scope="function", autouse=True)
async def session_override(app, connection_test):
    async def get_db_override():
        async with sessionmanager.session() as session:
            yield session

    app.dependency_overrides[get_db] = get_db_override

### END_FILE

### FILE: tests > integration > test_user_router.py
import pytest


class TestRouterUser:
    def test_create_user(client):
        response = client.get(
            "/users/",
            headers={"Authorization": f"Bearer "},
        )
        assert response.status_code == 401
        assert response.json() == []

        response = client.post(
            "/users/",
            json={
                "email": "test@example.com",
                "name": "Full Name Test",
                "password": "test",
            },
        )
        assert response.status_code == 200
        assert response.json().get("email") == "test@example.com"

        auth = client.post(
            "/auth/login/access-token",
            json={"username": "test@example.com", "password": "test"},
        )
        assert auth.status_code == 200
        assert auth.json().get("token_type") == "bearer"

        response = client.get(
            f"/users/{response.json().get('user_id')}",
            headers={"Authorization": f"Bearer {auth.json().get('access_token')}"},
        )
        assert response.status_code == 200
        assert response.json() == {
            "user_id": response.json().get("user_id"),
            "name": "Full Name Test",
            "email": "test@test.com",
            "password": "hidden",
        }

        response = client.get(
            "/users/",
            headers={"Authorization": f"Bearer {auth.json().get('access_token')}"},
        )
        assert response.status_code == 200
        assert len(response.json()) == 1

### END_FILE

### FILE: tests > models > test_account_model.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.models.models import User, Account


@pytest.fixture(scope="module")
def session():
    engine = create_engine(
        "sqlite:///:memory:",
        pool_recycle=300,
        pool_pre_ping=True,
    )
    Session = sessionmaker(bind=engine)
    User.metadata.create_all(engine)
    Account.metadata.create_all(engine)
    db = Session()
    try:
        yield db
    finally:
        db.rollback()
        db.close()


class TestDBAccount:

    def test_successful_user_creation(self, session):
        user = User(name="Test User", email="test@example.com", password="password")
        account = Account(user=user, account_name="My Account", account_type="savings")

        session.add(account)
        session.commit()

        qry_account = (
            session.query(Account).filter_by(account_name="My Account").first()
        )

        assert qry_account is not None
        assert len(qry_account.account_id) == 32
        assert qry_account.user_id == user.user_id
        assert qry_account.account_name == "My Account"
        assert qry_account.account_type == "savings"
        assert qry_account.currency == "COP"
        assert qry_account.initial_balance == 0

    def test_initial_balance_decimal(self, session):
        user = User(name="Test User", email="test2@example.com", password="password")
        account = Account(
            user=user,
            account_name="My Account2",
            account_type="savings",
            currency="USD",
            initial_balance=12345,
        )

        session.add(account)
        session.commit()

        qry_account = (
            session.query(Account).filter_by(account_name="My Account2").first()
        )

        assert qry_account.currency != "COP"
        assert qry_account.initial_balance == 12345.00

    def test_initial_balance_max(self, session):
        user = User(name="Test User", email="test3@example.com", password="password")
        account = Account(
            user=user,
            account_name="My Account3",
            account_type="savings",
            initial_balance=123456780.12345,
        )

        session.add(account)
        session.commit()

        qry_account = (
            session.query(Account).filter_by(account_name="My Account3").first()
        )

        assert qry_account.currency == "COP"
        assert float(qry_account.initial_balance) == 123456780.12  # Max 2 decimal

    def test_account_user_relationship(self, session):
        user = User(name="Test User", email="test4@example.com", password="password")
        account = Account(user=user, account_name="My Account4", account_type="savings")

        session.add(user)
        session.add(account)
        session.commit()

        assert account.user == user
        assert account in user.accounts

    def test_get_user_accounts(self, session):
        user = User(name="Test User", email="test5@example.com", password="password")
        account1 = Account(user=user, account_name="Account 1", account_type="savings")
        account2 = Account(user=user, account_name="Account 2", account_type="savings")

        session.add_all([user, account1, account2])
        session.commit()

        assert user.accounts == [account1, account2]

### END_FILE

### FILE: tests > models > test_category_model.py
import pytest
from datetime import datetime
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.models.models import Category, Transaction, User, Account


@pytest.fixture(scope="module")
def session():
    engine = create_engine(
        "sqlite:///:memory:",
        pool_recycle=300,
        pool_pre_ping=True,
    )
    Session = sessionmaker(bind=engine)
    User.metadata.create_all(engine)
    Account.metadata.create_all(engine)
    Category.metadata.create_all(engine)
    Transaction.metadata.create_all(engine)
    db = Session()
    try:
        yield db
    finally:
        db.rollback()
        db.close()


class TestDBCategory:

    def test_category_user_relationship(self, session):
        user = User(name="Test User", email="test@example.com", password="password")
        category = Category(user=user, category_name="Food", category_type="expense")

        session.add(user)
        session.add(category)
        session.commit()

        assert category.user == user
        assert category in user.categories

    def test_reassign_category_to_transaction(self, session):
        user = User(name="Test User", email="test2@example.com", password="password")
        account = Account(user=user, account_name="My Account", account_type="savings")
        food = Category(user=user, category_name="Food", category_type="expense")
        transport = Category(
            user=user, category_name="Transport", category_type="expense"
        )

        transaction = Transaction(
            user=user,
            category=food,
            account=account,
            date=datetime.now(),
            amount=50,
            transaction_type="expense",
        )

        session.add_all([food, transport, transaction])
        session.commit()

        transaction.category = transport
        session.commit()

        assert transaction not in food.transactions
        assert transaction in transport.transactions

    def test_transaction_category_relationship(self, session):
        user = User(name="Test User", email="test3@example.com", password="password")
        account = Account(user=user, account_name="My Account", account_type="savings")
        category = Category(user=user, category_name="Food", category_type="expense")
        transaction = Transaction(
            user=user,
            category=category,
            account=account,
            date=datetime.now(),
            amount=50,
            transaction_type="expense",
        )

        session.add_all([category, transaction])
        session.commit()

        assert transaction.category == category
        assert transaction in category.transactions

### END_FILE

### FILE: tests > models > test_transaction_model.py
import pytest
from datetime import datetime
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.models.models import Category, Transaction, User, Account


@pytest.fixture(scope="module")
def session():
    engine = create_engine(
        "sqlite:///:memory:",
        pool_recycle=300,
        pool_pre_ping=True,
    )
    Session = sessionmaker(bind=engine)
    User.metadata.create_all(engine)
    Account.metadata.create_all(engine)
    Category.metadata.create_all(engine)
    Transaction.metadata.create_all(engine)
    db = Session()
    try:
        yield db
    finally:
        db.rollback()
        db.close()


class TestDBCategory:
    def test_account_transaction_relationship(self, session):
        user = User(name="Test User", email="test@example.com", password="password")
        account = Account(user=user, account_name="My Account", account_type="savings")
        category = Category(user=user, category_name="Food", category_type="expense")

        transaction = Transaction(
            user=user,
            account=account,
            category=category,
            date=datetime.now(),
            amount=100,
            transaction_type="expense",
        )

        session.add_all([account, transaction])
        session.commit()

        assert transaction.account == account
        assert transaction in account.transactions

    def test_user_transaction_relationship(self, session):
        user = User(name="Test User", email="test2@example.com", password="password")
        account = Account(user=user, account_name="My Account", account_type="savings")
        category = Category(user=user, category_name="Food", category_type="expense")

        transaction = Transaction(
            user=user,
            account=account,
            category=category,
            date=datetime.now(),
            amount=100,
            transaction_type="expense",
        )

        session.add_all([user, account, transaction])
        session.commit()

        assert transaction.account.user == user
        assert transaction in user.accounts[0].transactions

### END_FILE

### FILE: tests > models > test_user_model.py
import pytest
from sqlalchemy.exc import IntegrityError
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.models.models import User, Account


@pytest.fixture(scope="module")
def session():
    engine = create_engine(
        "sqlite:///:memory:",
        pool_recycle=300,
        pool_pre_ping=True,
    )
    Session = sessionmaker(bind=engine)
    User.metadata.create_all(engine)
    Account.metadata.create_all(engine)
    db = Session()
    try:
        yield db
    finally:
        db.rollback()
        db.close()


class TestDBUser:

    def test_successful_user_creation(self, session):
        user = User(name="Test User", email="test@example.com", password="password")

        session.add(user)
        session.commit()

        qry_user = session.query(User).filter_by(email="test@example.com").first()

        assert qry_user is not None
        assert qry_user.name == "Test User"
        assert qry_user.email == "test@example.com"
        assert qry_user.password == "password"

    def test_on_delete_cascade(self, session):
        user = User(name="Test User 5", email="test5@example.com", password="password")
        account = Account(
            user=user, account_name="My Account 2", account_type="savings"
        )

        session.add_all([user, account])
        session.commit()

        session.delete(user)
        session.commit()

        assert session.query(User).filter_by(email="test5@example.com").first() is None
        assert (
            session.query(Account).filter_by(account_name="My Account 2").first()
            is None
        )

    def test_unique_email_constraint(self, session):
        user1 = User(name="User 1", email="test2@example.com", password="password1")
        user2 = User(name="User 2", email="test2@example.com", password="password2")

        session.add(user1)
        with pytest.raises(IntegrityError):
            session.add(user2)
            session.commit()

### END_FILE

